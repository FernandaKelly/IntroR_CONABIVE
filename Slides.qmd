---
title: "Introdução a linguagem de programação R e Suas Funcionalidades"
author: "Fernanda Kelly R. Silva | Estatística"
format: 
  revealjs:
    footer: "Slides por [Fernanda Kelly](https://fernandakellyrs.com). Slides [on GitHub](https://github.com/FernandaKelly/IntroR_CONABIVE)."
    slide-number: true
    preview-links: true
    chalkboard: true
    code-annotations: hover
    echo: true
    message: false
    warning: false
editor: visual
---

# Quem é a Fê?

Eu sou uma mulher preta com **coragem** e que fez (e ainda faz) uma boa limonada com os limões que a carreira na área da tecnologia oferece a todas minorias sociais.

# E faz o quê?

## Carreira Acadêmica

::: fragment
-   Graduada em Estatística pela Universidade Federal de Goiás (UFG);
:::

::: fragment
-   Especialista em Data Science e Analytics pela Universidade de São Paulo (USP);
:::

::: fragment
-   Especialista em Gerenciamento de Projetos pela Fundação Getúlio Vargas (FGV);
:::

::: fragment
-   Mestranda em Sistemas Inteligentes e Suas Aplicações na área da Saúde pela Universidade Federal em Ciências da Saúde de Porto Alegre (UFCSPA);
:::

# E sabe o que é o mais íncrivel de TUDO isso?

# {background-color="#B048A2"}

É que caminho ao lado de grandes mulheres.

![](img/turma_RLadiesgyn.jpg)

::: footer
Curso Introdução ao RBio e Experimentos ministrado por Dthenifer
:::

# 

Sou fundadora de um capítulo da organização mundial R-Ladies. Este capítulo é o [R-Ladies Goiânia](https://www.rladiesgyn.com/) e também faço parte do time global da organização [AI Inclusive](https://www.ai-inclusive.org/).

# E vocês?

# Vamos começar...

# Instalando o R (ou não?)

::: callout-important
Aqui é importante dizer que o nome da linguagem é R e o nome da IDE (integrated development environment) é RStudio, ou seja, a IDE RStudio é um ambiente de desenvolvimento que utilizamos para editar e executar os códigos em R. E claro, não existe somente a IDE RStudio que oferece a possibilidade de trabalhar com a linguagem R, há várias outras que também executam códigos em R, por exemplo: **Visual Studio Code (VSCode)**.
:::

## As opções...

Você tem duas opções para trabalhar com a IDE RStudio:

# Posit Cloud

::: fragment
Ou antigo [RStudio Cloud](https://www.fernandakellyrs.com/post/rstudio-cloud)
:::

::: fragment
-   Para acessar o [Posit Cloud](https://posit.cloud/) você pode fazer login com o gmail, GitHub ou qualquer outra conta que você tiver interesse em utilizar para o cadastro;
:::

::: fragment
-   Você poderá utilizar o espaço referente a 25 projetos e 25 horas (por mês) de computação. As horas de computação representam o uso da máquina virtual durante cada período para editar, executar, renderizar ou apresentar conteúdo.
:::

# 

-   Por padrão, cada projeto recebe 1 GB de RAM e 1 CPU, além de um limite de execução em segundo plano de 1 hora.

# Localmente

::: fragment
Ou seja, na sua máquina.
:::

::: fragment
-   No dia a dia, utilizar o R localmente é mais funcional e, para isso, você deve [instalar o R](https://posit.co/download/rstudio-desktop/);
-   Em relação a IDE RStudio você pode instalar [aqui](https://posit.co/download/rstudio-desktop/).
:::

# E porquê usar o R?

# 

-   É uma linguagem de programação que possui muitas ferramentas para análise de dados, visualização de dados e tantas outras ferramentas;

-   É código aberto (open source);

-   Possui uma comunidade ativa de pessoas desenvolvedoras ([curso-r fórum](https://discourse.curso-r.com/));

-   É flexível, permite desenvolver funções e pacotes para facilitar o trabalho;

-   Está disponível, gratuitamente, em diferentes sistemas operacionais: Windows, Linux e Mac.

# 

-   Os pacotes R contêm **código**, **dados** e **documentação** em um formato de coleção padronizado que pode ser instalado pelos usuários do R, normalmente por meio de um repositório de software centralizado como o **CRAN (Comprehensive R Archive Network)**.
-   O grande número de pacotes disponíveis para o R e a facilidade de instalação e uso deles são citados como um fator importante que impulsiona a adoção generalizada da linguagem na ciência de dados.

# 

Mas, por onde começar Fê?

# O início de tudo...

# ... são as boas práticas!

#

O ponto é: **vale mais a pena se esforçar para encontrar um par de meias no meio de uma gaveta bagunçada ou vale mais a pena se esforçar para arrumar uma gaveta bagunçada?**


# Step 1 {background-color="#FDE962"}

# 

Essa etapa do curso vai ser de muita troca e **live coding**. Vamos aprender as funcionalidades do R juntinhos e operantes, bora?

# Step 2 {background-color="#FDE962"}

# {background-image="img/tidyverse-default.png"}


#

O universo **Tidyverse** é basicamente uma coleção de pacotes voltados a ciência de dados. 


-   Estes pacotes tem filosofia, gramática e estruturas de dados  em comum, ou seja, foram criadas para um pacote poder trabalhar em conjunto com o outro. 

# {background-color="black"}

Os pacotes que fazem parte desse universo são: 

![](img/tidyverse_pacotes.jpeg)

# {background-image="img/tidyverse_forma.png"}

# Dplyr

## Funções que vamos aprender

O pacote auxilia na manipulação de dados, realizando-a de forma eficiente e, com essas funções, temos uma flexibilidade incrível para transformar nossos dados.

- rename(); distinct();   

- select(); filter();

- mutate(); transmute();

- arrange(); summarise(); 

- group_by(); sample_frac();

- sample_n().

# Mas antes de tudo...
# ... precisamos de uma base de dados!

# Base de dados

É importante dizer que há várias formas da gente conseguir encontrar bases de dados são várias, inclusive por meio de pacotes. Te convido a conhecer o pacote [**basedosdados**](https://basedosdados.org/) e desbravar as várias bases de dados disponíveis, mas hoje, nós vamos utilizar o banco de dados **CO2** que é do pacote **datasets**.

```{r}
library(datasets)
```

## Carbon Dioxide Uptake in Grass Plants

A absorção de $CO_{2}$ por seis plantas de Quebec e seis plantas do Mississippi foi medida em vários níveis de concentração ambiental. Metade das plantas de cada tipo foram resfriadas durante a noite antes da realização do experimento. Este conjunto de dados fazia originalmente parte do pacote nlme e possui métodos para suas classes de dados agrupados.

```{r}
dados_Carbon <- datasets::CO2
head(dados_Carbon,3)
```

## 

As variáveis que compõem o banco de dados são:

- Plant: um fator ordenado com níveis Qn1 < Qn2 < Qn3 < ... < Mc1 fornecendo um identificador único para cada planta.

- Type: um fator com dois níveis, sendo eles **Quebec** e **Mississippi** dando a origem da planta.

- Treatment: um fator com dois níveis, sendo eles **nonchilled** e **chilled**.

- conc: um vetor numérico de concentrações ambientais de dióxido de carbono (mL/L).

- uptake: um vetor numérico de taxas de absorção de dióxido de carbono ($\mu mol/m^{2} sec$).

# Vamos aprender manipulação de dados?

#  {background-image="img/featured.png"}


#

Pipes são uma ferramenta poderosa para expressar claramente uma sequência de múltiplas operações. A versão 4.0+ do R possui um pipe “nativo” **|>** que não depende da dependência do pacote magrittr. Aparentemente, ele deveria ser mais rápido que o pipe do pacote magrittr, por fazer muito mais “nos bastidores” do que o **%>%**. Você pode ler mais sobre isso em [R for Data Science](https://r4ds.had.co.nz/pipes.html). 

```{r}
library(magrittr)
```

#

Exemplo:

```{r}
x <- c(1.234, 2.4536, 3.442, 3.24, 1.2223)

sum(round(mean(x),2),5)

x %>% mean() %>% round(2) %>% sum(5)
```
---

# rename()

#

```{r}

```


# distinct()

#

```{r}

```

# select()

#

A função **select()** permite selecionar colunas nomeando-as e separando-as por vírgula ou não. Veremos exemplos abaixo.

```{r}
dados_Carbon %>% 
  dplyr::select(1,3) %>% 
  utils::head(3)
```

Veja que com o código abaixo a saída é a mesma:

```{r eval = FALSE}
dados_Carbon %>%
  dplyr::select(Plant, Treatment) %>% 
  utils::head(3)
```

#

Você pode selecionar colunas utilizando os dois pontos **:**, mas nesse caso, a seleção das colunas seguem a ideia de continuação. Por semplo:

```{r}
dados_Carbon %>% 
  dplyr::select(Plant:Treatment) %>% 
  utils::head(3)
```


#

Exisem funções no `dplyr` que ajudam na seleção das variáveis de uma outra forma:

- starts_with(): colunas que começam com um prefixo
- ends_with(): colunas que terminam com um sufixo
- contains(): colunas que contêm uma string
- last_col(): última coluna

#

```{r}
dados_Carbon %>% 
  dplyr::select(starts_with("Pl")) %>% 
  utils::head(3)
```

#

Esta função nos permite retirar colunas da base da seguinte forma:

```{r}
dados_Carbon %>% 
  dplyr::select(-Treatment) %>% 
  utils::head(3)
```


# filter()

#

Já a função **filter()** permite subdividir observações com base em seus valores. O primeiro argumento é o nome do quadro de dados. O segundo argumento e os subsequentes são as expressões que filtram o quadro de dados.

```{r include=FALSE}
dados_Carbon %>% 
  dplyr::filter(Treatment == "nonchilled") %>% 
  utils::head(3)
```

Quando você executa essa linha de código, o pacote `dplyr` executa a operação de filtragem e retorna um novo quadro de dados.

```{r}
dplyr::filter(dados_Carbon, Treatment == "nonchilled") %>% 
  utils::head(3)
```

#

Você pode também utilizar essa função de forma eficaz, você precisa saber como selecionar as observações desejadas usando os operadores de comparação. O R fornece o conjunto padrão: >, >=, <, <=, != (diferente) e == (igual).

```{r}
dplyr::filter(dados_Carbon, conc <= 95) %>% 
  utils::head(3)
```
#

Vários argumentos do **filter()** são combinados com **“e”**: cada expressão deve ser verdadeira para que uma linha seja incluída na saída. Para outros tipos de combinações, você mesmo precisará usar operadores booleanos: & é “e”, | é “ou” e ! é “não”. A Figura abaixo mostra o conjunto completo de operações booleanas.

![](img/boolenaos.jpeg)

#

No exemplo a seguir utilizamos o operador **<=** (menor igual) e o **&**:

```{r}
dados_Carbon %>% 
  dplyr::filter(conc <= 95 & Treatment == "nonchilled") %>% 
  utils::head(3)
```

# mutate()

#

Além de selecionar conjuntos de colunas existentes, geralmente é útil adicionar novas colunas que sejam funções de colunas existentes. Esse é o trabalho de mutate().

mutate()sempre adiciona novas colunas no final do seu conjunto de dados, então começaremos criando um conjunto de dados mais restrito para que possamos ver as novas variáveis. Lembre-se que quando você estiver no RStudio, a maneira mais fácil de ver todas as colunas é View().

```{r}

```

#

Observe que você pode consultar colunas que acabou de criar:


# transmute()

#

Se você quiser apenas manter as novas variáveis, use a função **transmute()**:

```{r}

```

# arrange()

#

A função **arrange()** orderna linhas.

- Se a variável for categórica ordena por ordem alfabética
- Se a variável for numérica ordena do menor para o maior
- Se a varíavel for um fator, ordena pelos níveis do fator

#

O exemplo abaixo ordena o banco de dados de acordo com a variável **uptake**.

```{r}
dados_Carbon %>%
  dplyr::arrange(uptake) %>% 
  utils::head(3)
```

#

Mas, nós podemos ordenar as linhas de forma decrescente usando a função **desc()**. Veja o exemplo abaixo.

```{r}
dados_Carbon %>% 
  dplyr::arrange(desc(uptake)) %>% 
  utils::head(3)
```

#

É também possível ordenar mais de uma coluna de uma vez

```{r}
dados_Carbon %>%
  dplyr::arrange(uptake, conc) %>% 
  utils::head(3)
```

# group_by()

#

```{r}

```

# summarise()

#

O último verbo chave é summarise(). Ele recolhe um quadro de dados em uma única linha:

```{r}

```

#

A função **summarise()** não é muito útil, a menos que o combinemos com **group_by()**. Isso altera a unidade de análise do conjunto de dados completo para grupos individuais. Então, quando você usar as funções `dplyr` em um quadro de dados agrupado, eles serão aplicados automaticamente “por grupo”. Por exemplo, se aplicarmos exatamente o mesmo código a um quadro de dados agrupado por data, obteremos o atraso médio por data:

```{r}

```

#

Juntos **group_by()** e **summarise()** fornecem uma das ferramentas que você usará mais comumente ao trabalhar com `dplyr`: resumos agrupados.

# case_when()

#

```{r}

```




# Teste de Hipóteses

# K-Means

