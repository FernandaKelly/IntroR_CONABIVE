{
  "hash": "227e77e3b6897e781f83795dbbb25666",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introdução a linguagem de programação R e Suas Funcionalidades\"\nauthor: \"Fernanda Kelly R. Silva | Estatística\"\nformat: \n  revealjs:\n    footer: \"Slides por [Fernanda Kelly](https://fernandakellyrs.com). Slides [on GitHub](https://github.com/FernandaKelly/IntroR_CONABIVE).\"\n    slide-number: true\n    preview-links: true\n    chalkboard: true\n    code-annotations: hover\n    echo: true\n    message: false\n    warning: false\neditor: visual\n---\n\n\n\n# Quem é a Fê?\n\nEu sou uma mulher preta com **coragem** e que fez (e ainda faz) uma boa limonada com os limões que a carreira na área da tecnologia oferece a todas minorias sociais.\n\n# E faz o quê?\n\n## Carreira Acadêmica\n\n::: fragment\n-   Graduada em Estatística pela Universidade Federal de Goiás (UFG);\n:::\n\n::: fragment\n-   Especialista em Data Science e Analytics pela Universidade de São Paulo (USP);\n:::\n\n::: fragment\n-   Especialista em Gerenciamento de Projetos pela Fundação Getúlio Vargas (FGV);\n:::\n\n::: fragment\n-   Mestranda em Sistemas Inteligentes e Suas Aplicações na área da Saúde pela Universidade Federal em Ciências da Saúde de Porto Alegre (UFCSPA);\n:::\n\n# E sabe o que é o mais íncrivel de TUDO isso?\n\n# {background-color=\"#B048A2\"}\n\nÉ que caminho ao lado de grandes mulheres.\n\n![](img/turma_RLadiesgyn.jpg)\n\n::: footer\nCurso Introdução ao RBio e Experimentos ministrado por Dthenifer\n:::\n\n# \n\nSou fundadora de um capítulo da organização mundial R-Ladies. Este capítulo é o [R-Ladies Goiânia](https://www.rladiesgyn.com/) e também faço parte do time global da organização [AI Inclusive](https://www.ai-inclusive.org/).\n\n# E vocês?\n\n# Vamos começar...\n\n# Instalando o R (ou não?)\n\n::: callout-important\nAqui é importante dizer que o nome da linguagem é R e o nome da IDE (integrated development environment) é RStudio, ou seja, a IDE RStudio é um ambiente de desenvolvimento que utilizamos para editar e executar os códigos em R. E claro, não existe somente a IDE RStudio que oferece a possibilidade de trabalhar com a linguagem R, há várias outras que também executam códigos em R, por exemplo: **Visual Studio Code (VSCode)**.\n:::\n\n## As opções...\n\nVocê tem duas opções para trabalhar com a IDE RStudio:\n\n# Posit Cloud\n\n::: fragment\nOu antigo [RStudio Cloud](https://www.fernandakellyrs.com/post/rstudio-cloud)\n:::\n\n::: fragment\n-   Para acessar o [Posit Cloud](https://posit.cloud/) você pode fazer login com o gmail, GitHub ou qualquer outra conta que você tiver interesse em utilizar para o cadastro;\n:::\n\n::: fragment\n-   Você poderá utilizar o espaço referente a 25 projetos e 25 horas (por mês) de computação. As horas de computação representam o uso da máquina virtual durante cada período para editar, executar, renderizar ou apresentar conteúdo.\n:::\n\n# \n\n-   Por padrão, cada projeto recebe 1 GB de RAM e 1 CPU, além de um limite de execução em segundo plano de 1 hora.\n\n# Localmente\n\n::: fragment\nOu seja, na sua máquina.\n:::\n\n::: fragment\n-   No dia a dia, utilizar o R localmente é mais funcional e, para isso, você deve [instalar o R](https://posit.co/download/rstudio-desktop/);\n-   Em relação a IDE RStudio você pode instalar [aqui](https://posit.co/download/rstudio-desktop/).\n:::\n\n# E porquê usar o R?\n\n# \n\n-   É uma linguagem de programação que possui muitas ferramentas para análise de dados, visualização de dados e tantas outras ferramentas;\n\n-   É código aberto (open source);\n\n-   Possui uma comunidade ativa de pessoas desenvolvedoras ([curso-r fórum](https://discourse.curso-r.com/));\n\n-   É flexível, permite desenvolver funções e pacotes para facilitar o trabalho;\n\n-   Está disponível, gratuitamente, em diferentes sistemas operacionais: Windows, Linux e Mac.\n\n# \n\n-   Os pacotes R contêm **código**, **dados** e **documentação** em um formato de coleção padronizado que pode ser instalado pelos usuários do R, normalmente por meio de um repositório de software centralizado como o **CRAN (Comprehensive R Archive Network)**.\n-   O grande número de pacotes disponíveis para o R e a facilidade de instalação e uso deles são citados como um fator importante que impulsiona a adoção generalizada da linguagem na ciência de dados.\n\n# \n\nMas, por onde começar Fê?\n\n# O início de tudo...\n\n# ... são as boas práticas!\n\n#\n\nO ponto é: **vale mais a pena se esforçar para encontrar um par de meias no meio de uma gaveta bagunçada ou vale mais a pena se esforçar para arrumar uma gaveta bagunçada?**\n\n\n# Step 1 {background-color=\"#FDE962\"}\n\n# \n\nEssa etapa do curso vai ser de muita troca e **live coding**. Vamos aprender as funcionalidades do R juntinhos e operantes, bora?\n\n# Step 2 {background-color=\"#FDE962\"}\n\n# {background-image=\"img/tidyverse-default.png\"}\n\n\n#\n\nO universo **Tidyverse** é basicamente uma coleção de pacotes voltados a ciência de dados. \n\n\n-   Estes pacotes tem filosofia, gramática e estruturas de dados  em comum, ou seja, foram criadas para um pacote poder trabalhar em conjunto com o outro. \n\n# {background-color=\"black\"}\n\nOs pacotes que fazem parte desse universo são: \n\n![](img/tidyverse_pacotes.jpeg)\n\n# {background-image=\"img/tidyverse_forma.png\"}\n\n# Dplyr\n\n## Funções que vamos aprender\n\nO pacote auxilia na manipulação de dados, realizando-a de forma eficiente e, com essas funções, temos uma flexibilidade incrível para transformar nossos dados.\n\n- rename(); distinct();   \n\n- select(); filter();\n\n- mutate(); transmute();\n\n- arrange(); summarise(); \n\n- group_by(); sample_frac();\n\n- sample_n().\n\n# Mas antes de tudo...\n# ... precisamos de uma base de dados!\n\n# Base de dados\n\nÉ importante dizer que há várias formas da gente conseguir encontrar bases de dados são várias, inclusive por meio de pacotes. Te convido a conhecer o pacote [**basedosdados**](https://basedosdados.org/) e desbravar as várias bases de dados disponíveis, mas hoje, nós vamos utilizar o banco de dados **CO2** que é do pacote **datasets**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(datasets)\n```\n:::\n\n\n\n## Carbon Dioxide Uptake in Grass Plants\n\nA absorção de $CO_{2}$ por seis plantas de Quebec e seis plantas do Mississippi foi medida em vários níveis de concentração ambiental. Metade das plantas de cada tipo foram resfriadas durante a noite antes da realização do experimento. Este conjunto de dados fazia originalmente parte do pacote nlme e possui métodos para suas classes de dados agrupados.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon <- datasets::CO2\nhead(dados_Carbon,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Plant   Type  Treatment conc uptake\n1   Qn1 Quebec nonchilled   95   16.0\n2   Qn1 Quebec nonchilled  175   30.4\n3   Qn1 Quebec nonchilled  250   34.8\n```\n\n\n:::\n:::\n\n\n\n## \n\nAs variáveis que compõem o banco de dados são:\n\n- Plant: um fator ordenado com níveis Qn1 < Qn2 < Qn3 < ... < Mc1 fornecendo um identificador único para cada planta.\n\n- Type: um fator com dois níveis, sendo eles **Quebec** e **Mississippi** dando a origem da planta.\n\n- Treatment: um fator com dois níveis, sendo eles **nonchilled** e **chilled**.\n\n- conc: um vetor numérico de concentrações ambientais de dióxido de carbono (mL/L).\n\n- uptake: um vetor numérico de taxas de absorção de dióxido de carbono ($\\mu mol/m^{2} sec$).\n\n# Vamos aprender manipulação de dados?\n\n#  {background-image=\"img/featured.png\"}\n\n\n#\n\nPipes são uma ferramenta poderosa para expressar claramente uma sequência de múltiplas operações. A versão 4.0+ do R possui um pipe “nativo” **|>** que não depende da dependência do pacote magrittr. Aparentemente, ele deveria ser mais rápido que o pipe do pacote magrittr, por fazer muito mais “nos bastidores” do que o **%>%**. Você pode ler mais sobre isso em [R for Data Science](https://r4ds.had.co.nz/pipes.html). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magrittr)\n```\n:::\n\n\n\n#\n\nExemplo:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1.234, 2.4536, 3.442, 3.24, 1.2223)\n\nsum(round(mean(x),2),5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.32\n```\n\n\n:::\n\n```{.r .cell-code}\nx %>% mean() %>% round(2) %>% sum(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.32\n```\n\n\n:::\n:::\n\n\n---\n\n# rename()\n\n#\n\nA primeira função que vamos estudar é a *rename()*. Esta função irá *renomear* as variáveis do banco de dados. Vejamos o exemplo a seguir:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>% \n  dplyr::rename(\"planta\" = \"Plant\") %>% \n  utils::head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  planta   Type  Treatment conc uptake\n1    Qn1 Quebec nonchilled   95   16.0\n2    Qn1 Quebec nonchilled  175   30.4\n3    Qn1 Quebec nonchilled  250   34.8\n```\n\n\n:::\n:::\n\n#\n\nNós temos também a opção da função **rename_with**, em que podemos aplicar funções de interesse para renomear as variáveis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>% \n  dplyr::rename_with(toupper) %>%\n  #dplyr::rename_with(tolower) %>%\n  utils::head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  PLANT   TYPE  TREATMENT CONC UPTAKE\n1   Qn1 Quebec nonchilled   95   16.0\n2   Qn1 Quebec nonchilled  175   30.4\n3   Qn1 Quebec nonchilled  250   34.8\n```\n\n\n:::\n:::\n\n#\n\nHá também as seguintes variações:\n\n- rename_if\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>% \n  dplyr::rename_if(is.factor, toupper) %>% \n  utils::head(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  PLANT   TYPE  TREATMENT conc uptake\n1   Qn1 Quebec nonchilled   95     16\n```\n\n\n:::\n:::\n\n\n- rename_at\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>% \n  dplyr::rename_at(vars(Plant:conc), toupper) %>% \n  utils::head(1)\n```\n:::\n\n\n#\n- rename_all\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>% \n  dplyr::rename_all(toupper) %>% \n  utils::head(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  PLANT   TYPE  TREATMENT CONC UPTAKE\n1   Qn1 Quebec nonchilled   95     16\n```\n\n\n:::\n:::\n\n\n\n# distinct()\n\n#\n\nA função **distinct()** seleciona apenas as linhas únicas (distintas) de uma determinada variável do banco de dados.\n\n\n::: {.cell}\n\n:::\n\n\n# select()\n\n#\n\nA função **select()** permite selecionar colunas nomeando-as e separando-as por vírgula ou não. Veremos exemplos abaixo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>% \n  dplyr::select(1,3) %>% \n  utils::head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Plant  Treatment\n1   Qn1 nonchilled\n2   Qn1 nonchilled\n3   Qn1 nonchilled\n```\n\n\n:::\n:::\n\n\nVeja que com o código abaixo a saída é a mesma:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>%\n  dplyr::select(Plant, Treatment) %>% \n  utils::head(3)\n```\n:::\n\n\n#\n\nVocê pode selecionar colunas utilizando os dois pontos **:**, mas nesse caso, a seleção das colunas seguem a ideia de continuação. Por semplo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>% \n  dplyr::select(Plant:Treatment) %>% \n  utils::head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Plant   Type  Treatment\n1   Qn1 Quebec nonchilled\n2   Qn1 Quebec nonchilled\n3   Qn1 Quebec nonchilled\n```\n\n\n:::\n:::\n\n\n\n#\n\nExisem funções no `dplyr` que ajudam na seleção das variáveis de uma outra forma:\n\n- starts_with(): colunas que começam com um prefixo\n- ends_with(): colunas que terminam com um sufixo\n- contains(): colunas que contêm uma string\n- last_col(): última coluna\n\n#\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>% \n  dplyr::select(starts_with(\"Pl\")) %>% \n  utils::head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Plant\n1   Qn1\n2   Qn1\n3   Qn1\n```\n\n\n:::\n:::\n\n\n#\n\nEsta função nos permite retirar colunas da base da seguinte forma:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>% \n  dplyr::select(-Treatment) %>% \n  utils::head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Plant   Type conc uptake\n1   Qn1 Quebec   95   16.0\n2   Qn1 Quebec  175   30.4\n3   Qn1 Quebec  250   34.8\n```\n\n\n:::\n:::\n\n\n\n# filter()\n\n#\n\nJá a função **filter()** permite subdividir observações com base em seus valores. O primeiro argumento é o nome do quadro de dados. O segundo argumento e os subsequentes são as expressões que filtram o quadro de dados.\n\n\n\n\n\nQuando você executa essa linha de código, o pacote `dplyr` executa a operação de filtragem e retorna um novo quadro de dados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::filter(dados_Carbon, Treatment == \"nonchilled\") %>% \n  utils::head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Plant   Type  Treatment conc uptake\n1   Qn1 Quebec nonchilled   95   16.0\n2   Qn1 Quebec nonchilled  175   30.4\n3   Qn1 Quebec nonchilled  250   34.8\n```\n\n\n:::\n:::\n\n\n#\n\nVocê pode também utilizar essa função de forma eficaz, você precisa saber como selecionar as observações desejadas usando os operadores de comparação. O R fornece o conjunto padrão: >, >=, <, <=, != (diferente) e == (igual).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::filter(dados_Carbon, conc <= 95) %>% \n  utils::head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Plant   Type  Treatment conc uptake\n1   Qn1 Quebec nonchilled   95   16.0\n2   Qn2 Quebec nonchilled   95   13.6\n3   Qn3 Quebec nonchilled   95   16.2\n```\n\n\n:::\n:::\n\n#\n\nVários argumentos do **filter()** são combinados com **“e”**: cada expressão deve ser verdadeira para que uma linha seja incluída na saída. Para outros tipos de combinações, você mesmo precisará usar operadores booleanos: & é “e”, | é “ou” e ! é “não”. A Figura abaixo mostra o conjunto completo de operações booleanas.\n\n![](img/boolenaos.jpeg)\n\n#\n\nNo exemplo a seguir utilizamos o operador **<=** (menor igual) e o **&**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>% \n  dplyr::filter(conc <= 95 & Treatment == \"nonchilled\") %>% \n  utils::head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Plant   Type  Treatment conc uptake\n1   Qn1 Quebec nonchilled   95   16.0\n2   Qn2 Quebec nonchilled   95   13.6\n3   Qn3 Quebec nonchilled   95   16.2\n```\n\n\n:::\n:::\n\n\n# mutate()\n\n#\n\nAlém de selecionar conjuntos de colunas existentes, geralmente é útil adicionar novas colunas que sejam funções de colunas existentes. Esse é o trabalho de mutate().\n\nmutate()sempre adiciona novas colunas no final do seu conjunto de dados, então começaremos criando um conjunto de dados mais restrito para que possamos ver as novas variáveis. Lembre-se que quando você estiver no RStudio, a maneira mais fácil de ver todas as colunas é View().\n\n\n::: {.cell}\n\n:::\n\n\n#\n\nObserve que você pode consultar colunas que acabou de criar:\n\n\n# transmute()\n\n#\n\nSe você quiser apenas manter as novas variáveis, use a função **transmute()**:\n\n\n::: {.cell}\n\n:::\n\n\n# arrange()\n\n#\n\nA função **arrange()** orderna linhas.\n\n- Se a variável for categórica ordena por ordem alfabética\n- Se a variável for numérica ordena do menor para o maior\n- Se a varíavel for um fator, ordena pelos níveis do fator\n\n#\n\nO exemplo abaixo ordena o banco de dados de acordo com a variável **uptake**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>%\n  dplyr::arrange(uptake) %>% \n  utils::head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Plant        Type Treatment conc uptake\n1   Mc2 Mississippi   chilled   95    7.7\n2   Qc2      Quebec   chilled   95    9.3\n3   Mc1 Mississippi   chilled   95   10.5\n```\n\n\n:::\n:::\n\n\n#\n\nMas, nós podemos ordenar as linhas de forma decrescente usando a função **desc()**. Veja o exemplo abaixo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>% \n  dplyr::arrange(desc(uptake)) %>% \n  utils::head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Plant   Type  Treatment conc uptake\n1   Qn3 Quebec nonchilled 1000   45.5\n2   Qn2 Quebec nonchilled 1000   44.3\n3   Qn3 Quebec nonchilled  675   43.9\n```\n\n\n:::\n:::\n\n\n#\n\nÉ também possível ordenar mais de uma coluna de uma vez\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_Carbon %>%\n  dplyr::arrange(uptake, conc) %>% \n  utils::head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Plant        Type Treatment conc uptake\n1   Mc2 Mississippi   chilled   95    7.7\n2   Qc2      Quebec   chilled   95    9.3\n3   Mc1 Mississippi   chilled   95   10.5\n```\n\n\n:::\n:::\n\n\n# group_by()\n\n#\n\nTemos a função *group_by()* que irá agrupar o banco de dados em relação a uma variável ou mais de uma.\n\n\n::: {.cell}\n\n:::\n\n\n# summarise()\n\n#\n\nO último verbo chave é summarise(). Ele recolhe um quadro de dados em uma única linha:\n\n\n::: {.cell}\n\n:::\n\n\n#\n\nA função **summarise()** não é muito útil, a menos que o combinemos com **group_by()**. Isso altera a unidade de análise do conjunto de dados completo para grupos individuais. Então, quando você usar as funções `dplyr` em um quadro de dados agrupado, eles serão aplicados automaticamente “por grupo”. Por exemplo, se aplicarmos exatamente o mesmo código a um quadro de dados agrupado por data, obteremos o atraso médio por data:\n\n\n::: {.cell}\n\n:::\n\n\n#\n\nJuntos **group_by()** e **summarise()** fornecem uma das ferramentas que você usará mais comumente ao trabalhar com `dplyr`: resumos agrupados.\n\n# case_when()\n\n#\n\nO **case_when** é uma generalização do **if_else()**. Cada caso é avaliado sequencialmente e a primeira correspondência de cada elemento determina o valor correspondente no vetor de saída. Se nenhum caso corresponder, o **.default** será usado como uma instrução final \"else\".\n\n- case_when() é um equivalente em R da CASE WHEN instrução `SQL` \"pesquisada\".\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n# Teste de Hipóteses\n\n# K-Means\n\n",
    "supporting": [
      "Slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}